# gjsy (Go JS Yourself!)

The goal of this project is to run a JavaScript interpreter in the Go
programming language. However, why would we want to do this in the first place?
JavaScript is an excellent language with much adoption in the front and back-end
of web development. One of the root principles of the language is the
event-based approach to solving concurrency and parallelism in run-time
execution. However, another approach would be to use multi-threading. Because of
its nature, JavaScript lacks multi-thread capabilities. So, in this project, we
will add a new directive to JavaScript, akin to Go's "goroutine" `go` directive.
We will implement it and allow us to fork threads in our interpreter, leveraging
the thread management to Go.

With this goal in mind, we decided to delimiter the number of instructions the
interpreter will support. Doing a full implementation for JavaScript would blow
the intentions of this exercise and probably would be impossible with limited
time constrain. We have support for the following:

* Literals:
  * Integer
  * Boolean
  * String
  * Null
  * Undefined
* Operations:
  * Prefix (`-` and `!`)
  * Binary (`+`, `-`, `/`, `*`, `%`)
  * Comparison (`&&`, `||`, `>`, `>=`, `<`, `<=`, `==`, `!=`)
* Statements:
  * New variable definition
    * Support for both `let` and `var` syntaxes (`var name = "value"`), also
      supporting uninitialized variables (`let name;` which have an `undefined`
      value)
  * Return
    * With the support of returning values, and without a value, it will return
      an `undefined`
  * Closures
* Expressions:
  * Function
    * With support for named (`function name() {}`), and anonymous functions
      (`function() {}`)
  * Function application (`function() {...}()`)
  * If/Else
  * While loops
  * Variable reassignment (`name = "new value"`)
  * Dot (`a.b`)
    * Even though we have support for the dot expression, we have a minimal
      object system, which is used just for built-in exposed functions, namely
      `console.log`, and a minimal barrier for the threads by using Go's
      `sync.WaitGroup`, exposing a single instance of a wait group and providing
      support for `wg.add(<integer>)`, `wg.done()` and `wg.wait()`
  * Go function application
    * This will start a new go routine (`go function() {...}()`)

As we preferred to emphasize the project's original goal (to bring
multi-threading to JavaScript), we decided not to implement some basic
operations like string concatenation and grouped expressions.

## Parsing and Tokenization

TODO

## Environment

The environment represents the evaluation context for any given expression.
It is defined in [engironment.go](./pkg/object/environment.go) and allows
the persistance of state during the lifetime of the program.

## Evaluation

The [evaluator](./pkg/evaluator/evaluator.go) is responsible for the execution
of the program. It does this by recursively evaluating the program, its
statements, and expressions. In the above file, there is a single switch
statement which selects on the token type to evaluate. Further evaluation
is conducted in subordonate files. For example the
[identifier.go](./pkg/evaluator/identifier.go) file evaluates an identifier
given the environment.

## Parallelism and Go

Perhaps the only unique facet of this project is the application of
go routines to evaluate function expressions in a
[go routine](https://golangbot.com/goroutines/). This can be found
in [function.go](./pkg/evaluator/function.go) in the
`applyGoFunction` function. This function spawns a new go routine
to run the `Eval` function given the current environment. The
routines generated by using the `go` application syntax can then
be waited on by using the built in `wg` object
[builtins.go](./pkg/evaluator/builtins.go). There is an example
of this in [multi_thread.js](./examples/multi_thread.js) which
can be run by using the following command:

```shell
make run FILE=examples/multi_thread.js
```
## Working with the Source Code

### Pre-requisites

This project uses Go 1.18, but the `Makefile` commands will run on Docker to
help with the project set up, prerequisites, etc. So, the only two
pre-requisites are:

* make
* [Docker](https://docs.docker.com/get-docker/)

### Testing

If using the provided `Makefile`, run:

```
make test
# or with Go
go test ./...
```

### Building

After building, a single binary `gjsy` can be found in the `build/bin`
directory, if running with go, it is usually installed in `$GOPATH/bin`

```
make build
# or
go install ./...
```

### REPL

This project includes a REPL, you can run it with:

```
make repl
# or
go run cmd/gjsy repl
```

### File interpreter

There are several provided examples in the `examples` directory, to interpret
a single file, run

```
make run FILE=examples/hello_world.js
# or
go run cmd/gjsy examples/hello_world.js
```

## Conclusion

## Credits

Miles Possing, Ivan Valdes Castillo

## References

This effort was heavily influenced by Thorsten Ball's book "Writing an
Interpreter in Go"
